[TOC]

# 前言

> 在总结这些设计模式期间我的感受是 , 对于每种模式的形态都很好理解 , 但最难的地方则是如何运用 , 也就是他的应用场景 , 这些应用场景并不能以一些简单的文字概括出来 , 甚至在运用时并不用完全遵照标准形态 , 所以在学习过程中需要着重的理解其意图 , 也就是该模式是为了解决何种问题? 其实很多模式我们都已经在用了,这个系列的总结主要是方便快速浏览某个模式的基本形态 , 方便查阅 , 也可以作为新手的入门指导.
>
> 对于设计模式的学习 , 我的建议是:
>
> 1. 随便找一篇博客了解他的基本用法 , 这时候已经知道他的形态 / 定义 / 大致使用场景 , 但仅限于知道 , 并没有深切体会.
>
> 2. 然后再找一本权威的书来参考实例 , 通常都会以一个非常简单的场景作为例子 , 此刻你应该思考他的大致应用场景 , 可以自己设计一个场景来带入.
> 3. 然后找到该模式在 Android源码或Java源码甚至是一些开源项目的源码的实际应用 , 此刻你对该模式的理解应该掌握到理解状态了.
> 4. 结合现在或以前的项目 , 找到该模式是否可以应用到你的项目中.
> 5. 最后用一段极简短的总结来总结该模式 , 然后结合该模式的定义做修正.
>
> 最后 , 几乎每种设计模式的应用都会带来代码量的急剧上升 , 可以说滥用设计模式还不如不用 , 所以对每种设计模式一定要达到深层理解才算是掌握 , 也才有可能在日后的项目中应用到.
>
> 这些总结笔记可能会放到博客上 , 希望可以帮到更多的程序猿 , 同时也是希望靠大家的智慧来完善这些总结 .
>
> 最后的最后 , 非常感谢那些乐于分享的小伙伴 , 本次总结参考了N多博客 , 主要参照有[这篇](http://c.biancheng.net/view/1317.html) , 其他的在此就不再列举了 , 有点多 , 正因为有了他们的分享 , 才使得知识获取变的如此快捷 . 以及参考了<*HearFirst设计模式*> / <*Android源码设计模式解析与实践*> 两本书.
>
> Coding for fun; 
>
> Share for fun;



# 准备工作

> 在开始之前 , 需要先了解一些基本概念:
>
> 1. **组合 / 聚合**
>    这个比较简单 , 就是整体和部分之间关系的强弱度 , 关系强度从上到下依次增强.
>    **依赖** : 单向存在 , 这种依赖具有临时性 , 偶然性 , Java中的表现为局部变量，方法中的参数和对静态方法的调用.
>    **关联** : 比依赖更强 , 可以双向存在 , Java中体现为被关联的类B以类属性的形式出现在类A中.
>    **聚合** : 是关联关系的特例 , 整体消失部分依然存在 , 在代码层面聚合与关联是一致的 , 只能从语义上来区分.
>    **组合** : 也是关联关系的一种特例 , 整体消失部分也消失 , 体现在代码层面与关联时一致的 , 只能从语义来区分 .
>    [了解更多](https://www.cnblogs.com/itplay/p/10671715.html)
> 2. **MUL图**
>    统一建模语言 , 详细可以看[这个](https://blog.csdn.net/monkey_d_meng/article/details/6005764) (作者摘自<大话设计模式>) . 

# 创建型模式

> 创建型模式主要关注如何创建对象 , 宗旨是使 **创建与使用分离**  , 使得我们不在关注对象的创建过程 , 而更专注于使用.
>
> 除了 *工厂方法模式* 属于类创建型模式，其他的全部属于对象创建型模式.

### [创建型模式之_单例模式](创建型模式之_单例模式.md) 

> 仅需要一个实例情.

### [创建型模式之_原型模式](创建型模式之_原型模式.md) 

>  快速创建多个类似的实例.

### [创建型模式之_工厂模式](创建型模式之_工厂模式.md) 

>  对对象实例化的管理;
>  包含 简单工厂模式 / 工厂方法模式 / 抽象工厂模式.

### [创建型模型之_建造模式](创建型模型之_建造模式.md) 

> 如果构造方法非常复杂
> 或者不同的组合方式会得到不同的结果.

# 结构型模式

> 结构型模式描述如何**将类或对象**按某种布局**组成更大的结构**。它分为**类结构型模式**和**对象结构型模式**，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。
>
> 除了适配器模式分为类结构型模式和对象结构型模式两种，其他的全部属于对象结构型模式.

### [结构型模式之_代理模式](结构型模式之_代理模式.md) 

> 不想让客户直接访问对象 或 访问目标对象有困难时
>
> 再或者需要对原对象的方法做扩展时 ,  可以通过代理来完成间接访问.

### [结构型模式之_适配器模式](结构型模式之_适配器模式.md) 

> 如果原本的接口不符合预期
>
> 或可以用适配器抽象出变化部分.

### [结构型模式之_桥接模式](结构型模式之_桥接模式.md) 

> 如果操作的结果收到两个维度变化影响 , 可以将变化1和变化2抽离出来.

### [结构型模式之_装饰模式](结构型模式之_装饰模式.md) 

> 可以增强原始类 , 而又不用继承的强耦合形态.

### [结构型模式之_外观模式](结构型模式之_外观模式.md) 

> 需要调用多个子系统或使用一系列复杂的系统 , 外观模式可以为系统对外提供一个简单统一的接口.

### [结构型模式之_享元模式](结构型模式之_享元模式.md) 

> 需要大量的相似对象的创建 , 为减小开销 , 可以共享元数据.

### [结构型模式之_组合模式](结构型模式之_组合模式.md) 

> 消除树状结构的层次感 , 在概念层面 , 你从来不觉得LinearLayout和ImageView是两个层的东西 , 
> 而都是View .
>
> 和类关系中的`组合`不同 , 这里的组合可以理解为将不同层级的对象组合为一个整体.

# 行为型模式

> 行为型模式用于描述程序在运行时复杂的**流程控制**，即**描述多个类或对象**之间怎样相互**协作**共同完成单个对象都无法单独**完成的任务**，它涉及算法与对象间**职责的分配**。
>
> 由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。
>
> 除了*模板方法模式*和*解释器模式*是**类行为型模式**，其他的全部属于**对象行为型模式**.

### [行为型模式之_状态模式](行为型模式之_状态模式.md) 

> 封装状态的切换 . 例如一个开关 , 你在开的时候无需将"开"这个参数传给他 , 只需要知道它现在的状态是关 , 只需要做按下这个操作即可 , 而无需关注他的目标状态.

### [行为型模式之_模板方法模式](行为型模式之_模板方法模式.md) 

> 很多表格类的东西都需要 , 固定部分无需改动 , 只需要将变化的部分留给实现类即可.

### [行为型模式之_策略模式](行为型模式之_策略模式.md) 

> 抽离算法 , 根据不同的策略结果体现出不同的结果.

### [行为型模式之_命令模式](行为型模式之_命令模式.md) 

> 将方法的调用封装成对象 , 以便记录操作.

### [结构型模式之_责任链模式](结构型模式之_责任链模式.md) 

> 用链式结构灵活的组合对象 , 处理一个请求.

### [行为型模式之_观察者模式](行为型模式之_观察者模式.md) 

> 类似广播功能 , 无需知道具体接收者是谁.

### [行为型模式之_中介模式](行为型模式之_中介模式.md) 

> 将网状的对象依赖关系简化为星装结构.

### [行为型模式之_备忘录模式](行为型模式之_备忘录模式.md) 

> 记录状态 , 以便再次使用时可以恢复到上次的状态.

### [行为型模式之_解释器模式](行为型模式之_解释器模式.md) 

> 对简单文法树的解析.

### [行为型模式之_访问者模式](行为型模式之_访问者模式.md) 

> 需要被访问的元素结构比较固定 , 而访问者对元素的操作又不尽相同.

### [行为型模式之_迭代器模式](行为型模式之_迭代器模式.md)

> 为不同的容器提供遍历方法 , 例如各类集合的iterator()方法.
>
> 对于日常开发几乎不怎么用的到.