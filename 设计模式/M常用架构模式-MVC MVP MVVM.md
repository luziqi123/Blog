### MVC / MVP / MVVM 他们之间的区别

**MVC : ** 

目的是将M和V的代实现代码分离 . 可以实现同一个应用程序有不同的表现形式 .

M(业务模型) 用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法。

V(用户界面) 视图层负责数据的展示。

C(控制器) 控制器是M和V之间的连接器，用于控制应用程序的流程。

在MVC中C只是连接或者说是控制View和Mode的 , 其实主要的业务逻辑是在Mode中的 . C只是起到一个协调的. M实则分为两部分 , 一部分是对数据的处理 , 一部分是提供View显示的数据.

主动MVC , M直接通知V来更新数据 , 通常View需要事先在Mode上注册, 以监视某些数据的变化来及时更新UI .

用户的对View操作以后，View捕获到这个操作，会把处理的权利交移给Controller（Pass calls）；Controller接着会执行相关的业务逻辑，这些业务逻辑可能需要对Model进行相应的操作；当Model变更了以后，会通过观察者模式（Observer Pattern）通知View；View通过**观察者模式**收到Model变更的消息以后，会向Model请求最新的数据，然后重新更新界面。如下图:

![](http://upload-images.jianshu.io/upload_images/1635594-d09edc47159aedaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

被动MVC , M对V和C一无所知 , 只是被使用. 服务器端通常会用这种模式 . 

缺点就是M和V是有联系的 , View的变动会直接影响到Mode . 



**MVP : **

V(UI抽象接口)

P(逻辑层接口)

M(数据层接口)

在MVC中 , V和M是有耦合的 , 而MVP则解除了这一层耦合 , P是V和M的桥梁 , V和M相互不知道对方.

MVP的重点在于 , P将V和M分离 , 将View层接口化 , 将Mode模块化 . V收到消息之后交由P来处理 , P处理完之后调用V的对应方法.

这里P做的其实就是将数据和UI相互绑定了 , 只不过需要我们手动的去定义V的接口 . 我们去手动完成了 V调用M , 然后M反馈给V的这么一个流程 . 所以P会显得比较笨重 .



**MVVM : **

ViewMode(视图模型)

V(视图层)

M(数据层)

视图通常包含了领域模型（Domain Model）和视图的状态（State）.比如一个列表 , 列表的内容是我们的领域模型 , 而列表的排列顺序和排列方式则是视图的状态了. ViewMode则更适合来描述一个View的状态 . 而领域模型则是交由DataBinding来处理的 . 

他的调用关系是 , 在View模板中就声明需要显示的内容那一块数据 , 以及需要交互的时候找谁 , 当V发出指令的时候 , VM则对该指令做出相应的操作 .  如果发生了数据的变更 , 数据变更后调用View的set方法则可以通知View改变数据.  因为ViewModel中的属性都实现了observable这样的接口，也就是说当使用属性的set的方法，都会同时触发属性修改的事件，使绑定的UI自动刷新 .

缺点: 不方便Debug , 

简单来说就是MVP解决了MVC 视图和逻辑数据层耦合的问题 , 但是产生了大量的接口 , 而MVVM则利用双向数据绑定解决了这一问题.