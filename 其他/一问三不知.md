[TOC]

# 临时记录

- Service中的Context和Brodcast中的Context是不一样的, 所以在Service中不能发送Toast , 而BroadCast中则可以.

  

- Show GPU Overdraw

- Profile GPU Rendering

- 优化view层级标签merge

- Compound Drawables，或自定义view

- 重组视图结构，如progressBar放到根视图的frameLayout上

- viewStub

- 尽可能不用layout_weight，每一层的“layout_weight”都会至少导致一次重新测量和重新布局，嵌套的使用会带来倍数的损失

- 资源图片9-Patch的尺寸：高与宽务必保证都是2的整数幂，会显著减少GPU渲染纹理的开销和出错机会

- 去掉DecorView的缺省背景：如果不需要应该去掉，减少一层绘制

- 合并static代码 , 减少文件个数 , 减少扫描dexfile耗时

- 减少线程间交互 

- 使用UDP下载图片



- 线程问题
- 设计模式
- 架构模式
- TCP/IP
- 



性能优化一般分为 界面感知优化 / 内存优化 / 网络优化 / 电量优化

网络优化通常就是尽量减少请求的次数和单次请求的数据包大小 , 请求次数的控制一般就是缓存了 , 再有就是需要后台给出一个比较合理的API , 如果有必要的话可以使用Gzip将请求压缩 , 再有就是如果你的app里面有个一socket链接 , 比如说一个聊天类的App , 这样的话一些碎片式的网络请求就没有必要再走短连接了 , 可以将大部分网络请求放到socket里面完成 . 

电量优化基本上没有涉及到 , 但是刚才提到的减少网络请求为的就是避免频繁发起请求造成的耗电情况.

平常接触到比较多的就是对界面感知和内存的优化了. 

界面卡顿的根本原因呢 , 就是无法在16ms内完成一次绘制 , 这里的16ms是绘制的整个流程 , 他包括CPU对Bitmap的加载处理 , 然后交由GPU栅格化渲染最后才由屏幕去绘制 , 而CPU和GPU永远处理的是下一帧的数据 , 放入缓存 , 然后系统会在每16ms发起一次垂直同步 , 来拿下一帧的数据 , 如果缓存里面是空的 , 那界面就仍然停在上一帧了 , 相当于每周迭代一个新版本 , 周一项目经理来验收工程了 ,  程序员说UI没出图 , 然后项目经理就走了 , 线上的依然是1.0版本 , 时间一长老板肯定就火了, 所以说一切影响CPU运行/影响GPU渲染/影响display绘制 的操作都有可能导致你的App掉帧 . 

对于display上层的绘制 , 减少View之间的重叠可以避免过度绘制 , 也有工具可以检测的到 , 还有就是在onDraw里面执行轻微的耗时操作,比如说Sp , for循环 , 以及浮点类型的复杂运算等 .

而CPU就比较多了 , 比如后台有音乐播放 , 下载什么的 , 都会占用CPU资源 , 而我们能控制的就是减少GC的回收 , 以为你GC在作垃圾回收的时候会停掉所有工作 , 包括UI线程 , 所以频繁GC肯定是影响性能的 ,  减少GC的方法只能是合理运用内存了 , 一般来说onDraw不是特别不像话就不会频繁出发GC . 比如说在里面创建对象了.

界面感知还有一个冷启动和热启动的问题 .这个就需要对内存做相关优化了.

OnTrimMemory方法可以让我们在退回后台的时候释放一些缓存和View , 同时也可以在即将被回收前做一些数据的持久化或者上传一些信息 , 总之就是尽量让我们的App占用更少的内存 .

使用一些三方的库可以有效防止内存泄露 LeakCanate









# 慕课视频

- **什么是activity?** 

  就是Android提供的一个界面,于用户进行交互.

- **activity的4种状态?** 

  running / paused / stopped / killed . 

  活动状态一切正常,在栈顶 / 失去焦点,不在栈顶,并不是被销毁,可能被回收 / 被完全覆盖 , 完全不可见 , 也可能被销毁 ./ 已经被回收了.

- **activity生命周期?** 

  onStart()的时候activity已经可以看见了,但无法交互. onResume() 可见并可交互. onPause调用之后activity就不能与用户交互了 , onStop调用之后,activity就有可能被回收. onRestart()从消失到可见时候调用.

- **Android进程优先级?** 

  前台 / 可见 / 服务 / 后台 / 空 .

  正在与用户交互的activity或者绑定的Service / 只是可见,但是不能点击的 / Service / 不可见 / ??

- **Android任务栈?** 

- **Android Scheme跳转协议?** 

  是一种页面内跳转协议 , 可以非常方便跳转app中的各个页面 , 通过该协议 , 服务器可以定制化告诉app跳转那个页面 , 可以通过通知栏消息定制化跳转页面 , 可以通过H5跳转页面等.

- **Fragment是第五大组件?** fragment比activity更节省内存,UI切换效果更好. 

- **Fragment加载方式** 静态加载 / 动态加载

  写到XML中 / 通过fragmentManager获取fragmentTransaction

- **FragmentPagerAdapter与FragmentStatePagerAdapter区别?**  

  用于页面较少情况 / 用于页面较多情况

  destroyItem方法中使用了detach , 只是将fragment脱离activity , 所以并不是真正回收 / destroyItem方法中 使用了remove , 真正释放了内存 , 所以更节省内存

  切换只是将UI分离 , 所以适合较少页面 / 每次切换都回收内存 , 适合页面较多情况.

- **Fragment生命周期?**

  onAttachd方法, activity与fragment关联之后所回调.

  onCreate方法 , Fragment初次创建调用

  onCreateView 当activity要得到fragment的layout时，调用此方法，fragment在其中创建自己的layout(界面)

  onViewCreated 绘制完成之后调用,可以初始化控件资源

  A------onCreate

  onActivityCreated方法 , activity被渲染成功之后调用

  A------onStart

  onStart方法 , 表示fragment也可见了

  A------onResume

  onResume方法 , fragment也可以交互了

  完全启动完毕.

  onPuse方法 , 不可交互了

  A------onPuset

  onStop方法, fragment不能与用户交互了

  A------onStop

  onDestoryView方法 , 当fragment中的视图被移除的时候，调用这个方法。表明fragment即将结束.

  onDestory方法 , fragment不在被使用了

  onDetach方法 , activity与fragment分离

  A------onDestory

- **Fragment通信?**

  Fragment -> Activity 通过getActivity

  Activity -> Fragment  接口回调

  Fragment -> Fragment  先getActivity 再 findFragmentById

- **replace  / add / remove**

  这就涉及到了一个Fragment栈

  将栈顶的移除 ,再添加到栈顶 / 直接添加到栈顶 / 从栈中移除

- **Service是什么?**

  可以在后台长时间运行操作且没有界面的应用组件 ,  和BroadCast一样都是UI线程.

- **Service和Thread区别**

  一个是UI线程的,一个是其他工作线程.查询文件网络请求用Thread , 数据的统计,音乐播放等用Service.

- **Service生命周期**

  onCreate 该方法只调用一次

  onStartCommand  每次调用startService就会调用他 , 返回一个int类型的值, 代表了是否在Service被回收后尝试重建.

  onBind 通过bindService方法启动才会被调用

  onDestroy 销毁

- **Broadcast 内部实现机制**

  Broadcast通过Binder机制向AMS进行注册

  广播发送者通过Binder机制向AMS发送广播

  AMS查找注册列表,将广播发送到BroadcastReceiver相应的消息队列中

  消息循环拿到此广播 , 调用BroadcastReceiver中的onReceive()方法

- **LocalBroadcastManager**

  只在本地发送的广播 , 只在App内传播 , 比全局广播更佳高效, 无法接受外部广播.不必担心泄露隐私数据.

  内部使用Handler实现.而不是Binder

- **WebView的一些漏洞和坑**

  1. API 16以及之前版本没有正确限制WebView.addJavascriptInterface方法 , 远程攻击者可以通过使用Java Reflection API利用该漏洞执行任意Java对象的方法.
  2. WebView写在其他容器里面 , 离开的时候需要销毁WebView , 先从父控件中remove掉 , 再调用webView的removeAllView 和 destory方法才不会造成内存泄露.
  3. jsbridge链接远端代码和native代码的桥梁.
  4. webViewClient.onPageFinished在网页加载完毕时加载 , 如果在网页中跳转的话,就会被调用无数次,所以使用WebChromeClient.onProgressChanged更靠谱一些.
  5. 后台耗电,webView会自己开启线程 , 如果没有正确销毁的话 , 会一直在后台运行.
  6. 硬件加速导致页面渲染问题

   webView其实是在新的线程当中 , 所以webView会一直持有一个Activity的引用.

- **Binder**

  Linux系统中每个进程都有一个虚拟地址, 不同的虚拟地址间是相互隔离的 . 如果需要通信的话, Android中就用到了Binder , Linux内核可以通过Socket来进行进程间通信 , 为何要用Binder? 因为Binder为我们做了性能上的优化和安全优化. 

- **Handler**

  在非UI线程使用Handler , 必须要先调用Looper.prepare方法 , 为当前线程创建一个Looper , 然后才能创建Handler , 还有就是需要调用Looper.loop()方法 , 开始对消息队列的轮询. 主线程之所以不用 , 是因为在ActivityThread的main方法中已经调用了Looper.prepareMainLooper()方法和loop()方法

  非静态内部类持有外部类的匿名引用 , 导致外部activity无法释放 , 造成内存泄露 . 可以吧handler改为静态内部类 , 或者在销毁时调用removeCallback() . 

- **AsyncTask**

  1. AsyncTask是Android提供的轻量级的异步类 , 是封装了线程池和handler的异步框架. 适合做耗时短的操作 . 

  2. 三个参数 : 执行时所需要的参数类型 , 进度类型 , 结果返回类型 

     onPreExecute 异步操作开始前调用

     doInBackground 耗时操作

     onProgressUpdate 进度回调

     onPostExecute 异步操作结束后调用

  3. AsyncTask注意事项:

     1. 内存泄露 , 也是因为非静态内部类持有外部类的匿名引用造成的.
     2. 结果丢失 , 由于activity被重新创建(如屏幕旋转) , 之前的AsyncTask持有的activity引用已经无效了.所以更新会无效.
     3. 更多详见上面总结的.....

- **handlerThread**

  为了解决频繁创建销毁线程造成的性能问题. 我们可以写一个Looper线程 , 不停的检查队列中的耗时任务 , 有的话就执行,执行完再接着执行下一个 . 为了解决这个常见的场景重复造轮子 , Android就提供了handlerThread框架.

  handlerThread就是一个内部含有Looper轮询器的Thread . 通过将其内部的Looper传递给handler , 来利用handler的消息队列机制完成耗时任务.

- **IntentService**

  IntentService继承了Service , 同时优先级比Service高 , 内部封装了HandlerThread和Handler . 也就是说内部有一个工作线程来处理耗时操作. 

  他在onCreate里面创建了一个HandlerThread , 和一个Handler .

- **UI卡顿**

  1. 做了轻微的耗时操作 , 
  2. 布局过于复杂 
  3. 同一时间动画执行的次数过多
  4. 内存频繁出发GC

- **内存管理机制**

  系统为App分配内存是根据物理内存大小分配一个小额数值 , 随后会在不够用的时候分配额外的内存. 但核心思想是让更多的进程存活. 所以Android建议不要真正推出应用 , 这样再次打开的时候会快很多 , 也省去了Application创建的时间 . 进程分为五类: 前台 / 可见 / 服务 / 后台 / 空 , 前三个在正常情况下是不会被系统杀死的. 而后台进程被存放在一个LRU缓存列表中 , 而在回收时涉及到回收效率的概念 , 其宗旨就是杀死更少的进程获得更多的内存.

  所以我们要让自己的App尽可能的占用较少的内存减少被回收的几率. 

  Service完成任务后及时停止 , 忘记关闭Service可能会造成内存泄露

  根据OnTrimMemory的紧张等级释放掉部分UI和缓存.

  及时使用Bitmap的recycle来释放资源

  合理使用容器





# 简历问题记录

1. 熟悉主流设计模式 / Android框架 , MVC / MVP / MVVM / 了解Dagger 2

   - 因为有了data-binding才使得MVVM更容易实现, VM
   - Dagger 2 是一款依赖注入框架 , 其实是把一个对象运行时所需要用到的对象的创建抽离了出来 , Spring框架是使用XML去配置 , 而Dagger 2则是通过注解来生成代码来配置的 . 最终都是为了遵循依赖倒置原则. (关于设计模式的其他原则还有 单一职责 , 里氏替换原则 , 接口隔离 , 开闭原则, 迪米特法则)

2. UI相关.

   - 绘制流程 : 

     绘制分为 measure , layout , draw . 而一个界面通常是一个View树 , 并且每一步都是递归操作的 , 直到整个树遍历完毕 , 然后才会进行下一步layout .

     **measure**: 计算视图的大小 , 在这里会确定视图的大小 , 并且调用onMeasure方法 , 子类可以调用setMeasuredDimension来保存大小 .

     **layout** 设置视图在屏幕中显示的位置 , 在调用onLayout的时候会有4个值 , 也就是左上角和右下角距离屏幕左上角的距离 . 通常由ViewGroup来实现 . 

     **draw** 通常会绘制如下一些东西 : 

     - 绘制背景
     - 绘制视图本身 , 即调用onDraw()函数.（比如TextView在这里实现了绘制文字的过程）
     - 绘制子视图，即dispatchDraw()函数 . 
     - 

     

   

[TOC]



# Service生命周期

两种启动方式.

**startService()**

- onCreate
- onStart
- onDestroy

**bindService()**

- onCreate
- onBind
- onUnbind
- onDestroy

# Android线程相关

### AsyncTask 相关

- AsyncTask是封装好的线程池，比起Thread+Handler的方式，AsyncTask在操作UI线程上更方便，因为onPreExecute()、onPostExecute()及更新UI方法onProgressUpdate()均运行在主线程中，这样就不用Handler发消息处理了；
- 如果我们的Activity销毁之前，没有取消 AsyncTask，这有可能让我们的AsyncTask崩溃(crash)。
- 如果AsyncTask被声明为Activity的非静态的内部类，那么AsyncTask会保留一个对创建了AsyncTask的Activity的引用。如果Activity已经被销毁，AsyncTask的后台线程还在执行，它将继续在内存里保留这个引用，导致Activity无法被回收，引起内存泄露。
- 屏幕旋转或Activity在后台被系统杀掉等情况会导致Activity的重新创建，之前运行的AsyncTask会持有一个之前Activity的引用，这个引用已经无效，这时调用onPostExecute()再去更新界面将不再生效。
- 在Android 1.6之前的版本，AsyncTask是串行的，在1.6至2.3的版本，改成了并行的。在2.3之后的版本又做了修改，可以支持并行和串行，当想要串行执行时，直接执行execute()方法，如果需要并行执行，则要执行executeOnExecutor(Executor)。并行情况下最大线程数为5 , 默认为串行


### Android Application线程相关


