> 泛型的引入使得一部分错误可以提前到编译时期发现，极大地增强了代码的健壮性。但是我们知道 java 泛型在运行的时候是会进行泛型擦除的. 
>
> **类型擦除是指泛型在运行的时候会去除泛型的类型信息**。java 中，泛型主要是在编译层次来实现的，在生成的字节码即 class 文件是不包括泛型的 类型信息的。即 List <String>， List<Object> ，List<Integer> 虽然在编译时候是不同的，但是在编译完成后，在 class 文件 中都只会把他们当作 List 来对待。
>
> 那我们要怎样得到在编译时期泛型的信息呢？java 为我们提供了 Type 接口，使用它，我们可以得到编译时期泛型的信息。



> Type 是所有类型的父接口, 如原始类型 (raw types 对应 Class)、 参数化类型(parameterized types 对应 ParameterizedType)、 数组类型(array types 对应 GenericArrayType)、 类型变量(type variables 对应 TypeVariable ) 和基本 (原生) 类型(primitive types 对应 Class),。
>
> 子接口有 ParameterizedType, TypeVariable, GenericArrayType, WildcardType, 实现类有 Class。



### **ParameterizedType （参数化类型）**

> ParameterizedType 表示一个参数化类型，如 Collection < string >

- **Type[] getActualTypeArguments();** 返回实际类型参数数组。 如 Map<String,Person> map 这个 ParameterizedType 返回的是 String 类,Person 类的全限定类名的 Type Array。

- **Type getRawType();** 返回的是当前这个 ParameterizedType 的类型。 如 Map<String,Person> map 这个 ParameterizedType 返回的是 Map 类的全限定类名的 Type Array。

- **Type getOwnerType();** 这个比较少用到。返回的是这个 ParameterizedType 所在的类的 Type （注意当前的 ParameterizedType 必须属于所在类的 member）。 比如 Map<String,Person> map 这个 ParameterizedType 的 getOwnerType() 为 null，而 Map.Entry<String, String>entry 的 getOwnerType() 为 Map 所属于的 Type。

